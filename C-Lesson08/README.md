# Урок по C №08. Массивы
## Вводная информация по структурам данных
_Хорошая_ программа на любом языке программирования должна отвечать следующим минимальным требованиям:
- корректно работать и выдавать правильные результаты;
- быть легко читаемой и понимаемой;
- быть леко отлаживаемой;
- быть легко модифицируемой (простой рефакторинг).

Также очевидно, что хорошая программа должна быть эффективной. Это означает, что она должна выполняться за минимально возможное время и потреблять минимум ресурсов.

Для того, чтобы создавать эффективные программы, нужно применять определенные концепции управления данными. __Структуры данных__ -- это критичная и основная часть управления данными.

__Структура данных__ -- это обычно группа элементов данных, объединенных под оним имененм, вводящая определеный способ хранения, доступа и организации данных внутри вычислительной машины для эффективного использования этих данных.

Структуры данных используются почти во всех программах или информационных системах, в частности:
- разработка компиляторов;
- пакеты статистического и численного анализа;
- искусственный интеллект;
- операционные системы;
- базы данных;
- графика.

## Классификация структур данных
Структуры данных в общем случае можно разделить на два класса: _тривиальные_ и _нетривиальные_ структуры данных.

Тривиальные структуры данных -- это фундаментальные типы данных, поддерживаемые языком программирования. Нетривиальнеые структуры данных создаются, используя тривиальные.

Нетривиальные структуры данных можно разделить на два типа: _линейные_ и _нелинейные_. Линейные структуры данных хранят свои элементы в линейном или последовательном порядке.

## Определение массива
__Массив__ -- это набор однотипных элементов. Элементы массива хранятся последовательно в непрерывном блоке памяти. Доступ к элементам массива осуществляется посредством их номера в массиве, или _индекса_. Нумерация элементов в массиве начинается с 0.

Элементы массивов размещаются в памяти непрерывно и занимают смежные адреса, для обхода которых может использоваться арифметика указателей.

## Объявление массива.
Маасив задается тремя параметрами:
- типом данных элементов (`type`), хранящихся в массиве;
- именем массива (`name`), чтобы иметь возможность обращаться к нему;
- размером массива (`size`), т.е. максимальным количетсвом элементов, которые можно сохранить в массиве.
Общая схема объявления массива следующая:
```c
type name[size];
```
Например,
```c
int arr[10];
```

## Инициализация массива во время объявления
Массивы поддерживают полную или частичную инициализацию, в том числе с помощью выделенных инициализаторов. В частично инициализированных массивах опущенные значения трактуются как нули.

Примеры инициализации массивов:
```c
int marks[5] = {90, 45, 67, 85, 78};
int marks[5] = {90, 45};
int marks[] =  {90 , 45, 72, 81, 63, 54};
int marks[5] = {0};
int marks[7] = {1, [5] = 10, 20, [1] = 2};
```

## Связь массивов и указателей
Имя массива -- это константный указатель на нулевой элемент массива, а именно:
```c
a == &a[0];
```
Для любых типов и длин массивов справедливо:
```c
&a[i] == a + i
```
и

```с
a[i] == *(a + i)
```

Отсюда можно сделать вывод об эквивалентности следующих объявлений (прототипов)функций:
```c
int foo(double[], int);
int foo(double*, int);
```

## Передача массива в функцию
Передать массив в функцию можно так, как показано выше, или как пару указателей: на 0-й и на N-й элементы:
```c
int foo(double*, double*);
```

## Массивы переменной длины
__Массивы переменной длины__ были введены в стандарте C99 и являются средством динамического, а не статического, распределения локальной памяти функций. Размеры таких массивов остаются неизвестными до момента исполнения функции.

Размер массива переменной длины:
- определяется переменными (отсюда и название);
- остается постоянным до момента уничтожения объекта.

Массивы переменной длины выделяются и размещаются в стеке, поэтому их нельзя инициализировать при создании. Уничтожаются они автоматически при выходе из блока, где они были объявлены, поэтому их использование абсолютно безопасно и не вызывает никаких утечек памяти.

Примеры:
```c
// прототип функции
int foo(size_t rows, double a[rows]);
int foo(size_t, double a[*]);

// определение функции
int foo(size_t rows, double a[rows])
{ /* ... */ }

int bar()
{
    int n =3;
    int var[n]; // массив как локальная переменная
}
```